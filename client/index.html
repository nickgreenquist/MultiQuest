<!DOCTYPE html>
<html lang="en">
<head>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"></script>
    <script type="text/babel" >
        "use strict";

        var socket;

        let canvas;
        let ctx;
        let sendBufferCanvas;
        let sendBufferCtx;
        let isHost = false;

        const user = `user${(Math.floor((Math.random()*1000)) + 1)}`;

        let players = {};
        let enemies = {};
        //player object definition
        /*
          players[user] = 
          {
            lastUpdate,
            position = 
            {
              x,
              y,
              width,
              height
            },
            maxHealth,
            currentHealth,
            dead,
            speed,
            attack
          }
        */
        

        const init = () => {
            socket = io.connect();
            
            canvas = document.querySelector("#canvas");
            ctx = canvas.getContext("2d");
            
            //connecting the socket
            socket.on('connect', () => {
                console.log('connecting');
                
                socket.emit('join', user);     
            });
          
            socket.on('setHost', (data) => {
              isHost = data;
              console.log("You are the host");
              setupPlayer();
              setupEnemy();
              draw();
            })
            
            socket.on('getPlayersHost', (data) => {
               if(isHost) {
                 updatePlayerHost(data);
               }
            });
          
            socket.on('getAllPlayers', (data) => {
              updatePlayers(data);
            });
          
            socket.on('getEnemyHost', (data) => {
              updateEnemyHost(data);
            });
          
            socket.on('getAllEnemies', (data) => {
              updateEnemies(data);
            });
          
            socket.on('requestWorldData', (data) => {
              if(isHost) {
                let worldData = {players:players, enemies:enemies};
                socket.emit('updateWorldData', worldData);
              }
            });
          
            socket.on('getWorldData', (data) => {
              console.log('getting initial world data');
              players = data.players;
              enemies = data.enemies;
              setupPlayer();
              draw();
            });
            
            window.addEventListener("keydown", move, true);
        };

      
        const move = (e) => {
          console.log("Detected key press");
          if ( e.keyCode == 68 ) {
            const time = new Date().getTime();
            
            //only move if enough time has occured, otherwise server is overloaded
            if(time - players[user].lastUpdate > 100) {
              players[user].lastUpdate = time;
            
              //check collision with enemy before emitting
              let isColliding = false;
              let keys = Object.keys(enemies);
              for(let i = 0; i < keys.length; i++)
              {
                const collisionCall = enemies[keys[i]];
                if(!players[user].dead && !enemies[keys[i]].dead && (players[user].position.x + players[user].position.width) > enemies[keys[i]].position.x ) {
                  isColliding = true;
                  
                  //combat
                  players[user].currentHealth -= enemies[keys[i]].attack;
                  if(players[user].currentHealth <= 0) {
                    players[user].dead = true;
                  }
                  socket.emit('updatePlayer', {name: user, playerInfo: players[user]});
                  
                  enemies[keys[i]].currentHealth -= players[user].attack;
                  if(enemies[keys[i]].currentHealth <= 0) {
                    enemies[keys[i]].dead = true;
                  }
                  socket.emit('updateEnemy', {name: keys[i], enemyInfo:enemies[keys[i]]});
                  
                  //should I draw here even though server hasn't received update?
                  draw();
                }
              }
            
              if(!isColliding && !players[user].dead) {
                players[user].position.x += players[user].speed;
                socket.emit('updatePlayer', {name: user, playerInfo: players[user]});
                
                draw();
              }
            }
          }
        };

        const setupPlayer = () => {            
            const time = new Date().getTime();
            let x = 0;
            let y = 300;
            let position = {x:x, y:y,width:100,height:100};
            players[user] = {lastUpdate: time, position:position, maxHealth:10, currentHealth:10,dead:false,speed:10,attack:2};
        };

        const setupEnemy = () => {            
            const time = new Date().getTime();         
            let x = 200;
            let y = 300;
          
            for(let i = 1; i <= 5; i++) {
                let position = {x:x + (i*200), y:y, width:100, height:100};
                enemies[`enemy${i}`] = {lastUpdate: time, position:position, maxHealth:10, currentHealth:10,dead:false,attack:1};
            }
        };


        const draw = () => {
          ctx.clearRect(0,0,canvas.width, canvas.height);
            
          let keys = Object.keys(players);
            
          console.log(`Drawing ${keys.length} players`);
          for(let i = 0; i < keys.length; i++)
          {
            const drawCall = players[keys[i]];
            if(drawCall.dead) {
              ctx.globalAlpha = 0.5;
            }
            ctx.fillStyle = "black";
            ctx.fillRect(drawCall.position.x, drawCall.position.y, drawCall.position.width, drawCall.position.height);
            ctx.font = "36px serif";
            ctx.strokeText(keys[i], drawCall.position.x, drawCall.position.y - 50);
            
            //draw health bar
            ctx.globalAlpha = 1;
            ctx.fillStyle="white";
            ctx.fillRect(drawCall.position.x,drawCall.position.y - 40, drawCall.position.width, 30);
            ctx.fillStyle="black";
            ctx.fillRect(drawCall.position.x + 3,drawCall.position.y -37 , drawCall.position.width - 6, 24);
            ctx.fillStyle="green";
            ctx.fillRect(drawCall.position.x + 3,drawCall.position.y - 37,(drawCall.currentHealth / drawCall.maxHealth) * (drawCall.position.width - 6) ,24);
          }
        
          keys = Object.keys(enemies);
          console.log(`Drawing ${keys.length} enmies`);
          for(let i = 0; i < keys.length; i++)
          {
            const drawCall = enemies[keys[i]];
            if(drawCall.dead) {
              ctx.globalAlpha = 0.5;
            }
            ctx.fillStyle = "red";
            ctx.fillRect(drawCall.position.x, drawCall.position.y, drawCall.position.width, drawCall.position.height);
            
            //draw health bar
            ctx.globalAlpha = 1;
            ctx.fillStyle="white";
            ctx.fillRect(drawCall.position.x,drawCall.position.y - 40, drawCall.position.width, 30);
            ctx.fillStyle="black";
            ctx.fillRect(drawCall.position.x + 3,drawCall.position.y -37 , drawCall.position.width - 6, 24);
            ctx.fillStyle="green";
            ctx.fillRect(drawCall.position.x + 3,drawCall.position.y - 37,(drawCall.currentHealth / drawCall.maxHealth) * (drawCall.position.width - 6) ,24);
          }
        };

        const updatePlayerHost = (data) => {
            //check if player should be redrawn
            if(!players[data.name])
            {
                players[data.name] = data.playerInfo;
            }
            else
            {
                 players[data.name] = data.playerInfo;
            }
          
            //host has updated player coords, emit back to server to be emitted to all users
            socket.emit('updateAllPlayers', players);
        };

        const updatePlayers = (data) => {
            players = data;
            
            draw(); //redraw after we update
        };

        const updateEnemyHost = (data) => {
          enemies[data.name] = data.enemyInfo;
          
          socket.emit('updateAllEnemies', enemies);
        };
            
        const updateEnemies = (data) => {
          enemies = data;
          
          draw();
        };
        

        window.onload = init;

        window.onbeforeunload = function(){
            socket.emit('leave', isHost);
        }
    
    </script>
</head>
<body>
    <canvas id="canvas" height="768" width="1366" style="background-image:url('background1.png');">Please use an HTML 5 browser</canvas>
</body>
</html>